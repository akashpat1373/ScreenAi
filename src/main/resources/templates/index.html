<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>ScreenAI - Screen Sharing POC</title>
   <style>
       * {
           margin: 0;
           padding: 0;
           box-sizing: border-box;
       }
      
       body {
           font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
           background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
           min-height: 100vh;
           color: white;
           overflow: hidden;
       }
      
       .control-panel {
           display: flex;
           align-items: center;
           justify-content: center;
           min-height: 100vh;
           padding: 20px;
           text-align: center;
           background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
           color: white;
       }
      
       .container {
           max-width: 600px;
           text-align: center;
           padding: 40px 30px;
           background: rgba(255, 255, 255, 0.1);
           border-radius: 20px;
           backdrop-filter: blur(10px);
           border: 1px solid rgba(255, 255, 255, 0.2);
           box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
       }
      
       .logo {
           font-size: 3.5rem;
           font-weight: bold;
           margin-bottom: 20px;
           background: linear-gradient(45deg, #4CAF50, #2196F3);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           background-clip: text;
       }
      
       .tagline {
           font-size: 1.3rem;
           margin-bottom: 30px;
           opacity: 0.9;
           line-height: 1.6;
       }
      
       .features {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
           gap: 20px;
           margin: 40px 0;
       }
      
       .feature {
           padding: 20px;
           background: rgba(255, 255, 255, 0.05);
           border-radius: 15px;
           border: 1px solid rgba(255, 255, 255, 0.1);
           transition: transform 0.3s ease;
       }
      
       .feature:hover {
           transform: translateY(-5px);
       }
      
       .feature-icon {
           font-size: 2rem;
           margin-bottom: 10px;
       }
      
       .feature h3 {
           margin-bottom: 10px;
           color: #4CAF50;
       }
      
       .feature p {
           opacity: 0.8;
           line-height: 1.5;
       }
      
       /* Stream Viewer Styles */
       .stream-viewer {
           display: none;
           position: relative;
           width: 100vw;
           height: 100vh;
           background: #000;
       }
      
       #screenView {
           width: 100%;
           height: 100%;
           object-fit: contain;
           background-color: #000;
       }
      
       /* Status and capture info boxes removed */
      
       /* Control panel styling merged with landing styles above */
      
       .control-panel h1 {
           font-size: 3rem;
           font-weight: bold;
           margin-bottom: 20px;
           background: linear-gradient(45deg, #4CAF50, #2196F3);
           -webkit-background-clip: text;
           -webkit-text-fill-color: transparent;
           background-clip: text;
       }
      
       .control-status {
           background: rgba(255,255,255,0.1);
           padding: 20px;
           border-radius: 15px;
           margin: 30px auto;
           max-width: 400px;
           border: 1px solid rgba(255, 255, 255, 0.2);
       }
      
       .status-line {
           margin: 10px 0;
           font-size: 16px;
       }
      
       .status-value {
           color: #4CAF50;
           font-weight: bold;
       }
      
       .error {
           position: absolute;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           color: white;
           text-align: center;
           background: rgba(0, 0, 0, 0.8);
           padding: 30px;
           border-radius: 10px;
           display: none;
       }
      
       .error button {
           background: #4CAF50;
           color: white;
           border: none;
           padding: 10px 20px;
           border-radius: 5px;
           cursor: pointer;
           margin-top: 15px;
       }
      
       .error button:hover {
           background: #45a049;
       }
      
       /* 🕒 Stream Timestamp Styles */
       .stream-timestamp {
           display: inline-block !important;
           margin-right: 20px;
           padding: 12px 16px;
           background: rgba(0, 0, 0, 0.85);
           border-radius: 8px;
           color: white;
           font-family: 'Courier New', monospace;
           font-size: 12px;
           line-height: 1.2;
           border: 1px solid rgba(76, 175, 80, 0.5);
           backdrop-filter: blur(5px);
           box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
           min-width: 160px;
           position: relative;
       }


       .stream-timestamp-row {
           display: flex;
           align-items: center;
           gap: 8px;
           margin: 3px 0;
       }


       .stream-timestamp-label {
           font-size: 10px;
           opacity: 0.8;
           min-width: 45px;
           color: #ccc;
       }


       .stream-timestamp-value {
           color: #4CAF50;
           font-weight: bold;
           font-size: 12px;
       }


       .stream-timestamp-value.elapsed {
           color: #FF9800;
           font-size: 13px;
           font-weight: bold;
           animation: pulse 2s ease-in-out infinite;
       }
      
       @keyframes pulse {
           0%, 100% { opacity: 1; }
           50% { opacity: 0.7; }
       }
      
       /* Button Styles */
       .btn {
           padding: 15px 30px;
           margin: 10px;
           border: none;
           border-radius: 10px;
           cursor: pointer;
           font-size: 18px;
           font-weight: bold;
           transition: all 0.3s;
           min-width: 180px;
       }
      
       .btn-lg {
           padding: 20px 40px;
           font-size: 20px;
           min-width: 220px;
       }
      
       .btn:hover {
           transform: translateY(-2px);
           box-shadow: 0 6px 20px rgba(0,0,0,0.3);
       }
      
       .btn:disabled {
           opacity: 0.6;
           cursor: not-allowed;
           transform: none;
       }
      
       .btn-success {
           background: #27ae60;
           color: white;
       }
      
       .btn-danger {
           background: #e74c3c;
           color: white;
       }
      
       .btn-secondary {
           background: #6c757d;
           color: white;
       }
      
       .btn-primary {
           background: linear-gradient(45deg, #4CAF50, #2196F3);
           color: white;
           border: none;
       }
      
       .loading {
           display: inline-block;
           animation: spin 1s linear infinite;
       }
      
       @keyframes spin {
           0% { transform: rotate(0deg); }
           100% { transform: rotate(360deg); }
       }
      
       .hidden {
           display: none !important;
       }
      
       /* Stream Controls */
       .stream-controls {
           position: fixed;
           bottom: 30px;
           left: 50%;
           transform: translateX(-50%);
           display: none;
           align-items: center;
           z-index: 1001;
           background: rgba(0, 0, 0, 0.7);
           padding: 15px;
           border-radius: 12px;
           border: 1px solid rgba(255, 255, 255, 0.2);
           backdrop-filter: blur(10px);
           box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
       }
      
       .stream-controls.show {
           display: flex !important;
       }


       /* Session Summary on Home Screen */
       .session-results {
           position: fixed;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           background: rgba(0, 0, 0, 0.95);
           padding: 30px;
           border-radius: 15px;
           border: 2px solid #4CAF50;
           color: white;
           min-width: 400px;
           max-width: 500px;
           z-index: 2000;
           backdrop-filter: blur(15px);
           box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
       }


       .session-results h3 {
           color: #4CAF50;
           margin-bottom: 20px;
           text-align: center;
           font-size: 20px;
           border-bottom: 1px solid rgba(76, 175, 80, 0.3);
           padding-bottom: 10px;
       }


       .session-detail {
           display: flex;
           justify-content: space-between;
           margin: 12px 0;
           padding: 10px 0;
           border-bottom: 1px solid rgba(255, 255, 255, 0.1);
           font-size: 15px;
       }


       .session-detail:last-child {
           border-bottom: none;
       }


       .session-detail-label {
           opacity: 0.9;
           font-weight: 500;
       }


       .session-detail-value {
           color: #4CAF50;
           font-family: 'Courier New', monospace;
           font-weight: bold;
       }


       .session-duration {
           color: #FF9800 !important;
           font-size: 18px !important;
       }


       /* Mobile responsive */
       @media (max-width: 768px) {
           .stream-timestamp {
               display: block;
               margin: 0 auto 15px auto;
               font-size: 10px;
               padding: 6px 10px;
           }
          
           .stream-timestamp-value.elapsed {
               font-size: 11px;
           }
          
           .session-results {
               min-width: 300px;
               padding: 20px;
           }
       }
   </style>
</head>
<body>
   <!-- Screen AI Control Center as Landing Page -->
   <div id="controlPanel" class="control-panel">
       <div class="container">
           <h1>🎥 Screen AI</h1>
          
           <div id="controlStatus" class="control-status">
               <div class="status-line">Status: <span id="statusText" class="status-value">Ready</span></div>
               <div class="status-line">Active Viewers: <span id="activeViewers" class="status-value">0</span></div>
               <div class="status-line">Network: <span class="status-value">Connected</span></div>
           </div>
          
           <div>
               <button id="startStreamBtn" class="btn btn-success btn-lg">
                   <span id="startBtnText">🚀 Start Screen Sharing</span>
                   <span id="startLoading" class="loading hidden">⏳</span>
               </button>
           </div>
       </div>
   </div>
  
   <!-- Stream Viewer -->
   <div id="streamViewer" class="stream-viewer">
       <img id="screenView" alt="Screen Share Stream" />
  
   <!-- Stream Controls with Timestamp -->
   <div id="streamControls" class="stream-controls">
       <!-- 🕒 Compact Stream Timestamp -->
       <div id="streamTimestamp" class="stream-timestamp">
           <div class="stream-timestamp-row">
               <span class="stream-timestamp-label">Started:</span>
               <span id="compactStartTime" class="stream-timestamp-value">--:--:--</span>
           </div>
           <div class="stream-timestamp-row">
               <span class="stream-timestamp-label">Elapsed:</span>
               <span id="compactElapsedTime" class="stream-timestamp-value elapsed">00:00:00</span>
           </div>
       </div>
      
       <button id="stopBtn" class="btn btn-danger">
           <span id="stopBtnText">🛑 Stop Streaming</span>
           <span id="stopLoading" class="loading hidden">⏳</span>
       </button>
   </div>
   </div>
  
   <!-- Error Display -->
   <div id="error" class="error">
       <h3>Connection Error</h3>
       <p id="errorMessage">Unable to connect to the screen sharing server.</p>
       <button onclick="location.reload()" class="btn" style="background: white; color: #e74c3c; margin-top: 10px;">Retry Connection</button>
   </div>
  
   <!-- 🕒 Session Results (shown on screen after session) -->
   <div id="sessionResults" class="session-results" style="display: none;">
       <h3>📊 Session Completed</h3>
       <div class="session-detail">
           <span class="session-detail-label">🚀 Started:</span>
           <span id="resultStartTime" class="session-detail-value">--:--:--</span>
       </div>
       <div class="session-detail">
           <span class="session-detail-label">🛑 Ended:</span>
           <span id="resultStopTime" class="session-detail-value">--:--:--</span>
       </div>
       <div class="session-detail">
           <span class="session-detail-label">⏱️ Duration:</span>
           <span id="resultDuration" class="session-detail-value session-duration">00:00:00</span>
       </div>
       <div class="session-detail">
           <span class="session-detail-label">📅 Date:</span>
           <span id="resultDate" class="session-detail-value">--/--/----</span>
       </div>
       <div style="text-align: center; margin-top: 20px;">
           <button class="btn" style="background: #4CAF50; color: white;" onclick="document.getElementById('sessionResults').style.display='none'">Close</button>
       </div>
   </div>
  
   <div id="error" class="error">
       <h3>Connection Error</h3>
       <p id="errorMessage">Unable to connect to the screen sharing server.</p>
       <button onclick="location.reload()">Retry Connection</button>
   </div>


   <script>
       class ScreenAIManager {
           constructor() {
               this.socket = null;
               this.reconnectAttempts = 0;
               this.maxReconnectAttempts = 5;
               this.frameCount = 0;
               this.lastFrameTime = Date.now();
               this.isStreaming = false;
               this.intentionalStop = false;
              
               // Page elements
               this.controlPanel = document.getElementById('controlPanel');
               this.streamViewer = document.getElementById('streamViewer');
              
               // Controls
               this.startStreamBtn = document.getElementById('startStreamBtn');
               this.stopBtn = document.getElementById('stopBtn');
              
               // Stream elements
               this.screenView = document.getElementById('screenView');
               this.errorElement = document.getElementById('error');
               this.errorMessage = document.getElementById('errorMessage');
               this.statusText = document.getElementById('statusText');
               this.activeViewers = document.getElementById('activeViewers');
              
               // 🕒 Timestamp tracking
               this.startTime = null;
               this.stopTime = null;
               this.elapsedTimer = null;
               this.isStreaming = false;
              
               // Timestamp elements
               this.streamControls = document.getElementById('streamControls');
               this.streamTimestamp = document.getElementById('streamTimestamp');
               this.compactStartTime = document.getElementById('compactStartTime');
               this.compactElapsedTime = document.getElementById('compactElapsedTime');
               this.stopBtn = document.getElementById('stopBtn');
              
               // Session results elements
               this.sessionResults = document.getElementById('sessionResults');
               this.resultStartTime = document.getElementById('resultStartTime');
               this.resultStopTime = document.getElementById('resultStopTime');
               this.resultDuration = document.getElementById('resultDuration');
               this.resultDate = document.getElementById('resultDate');
              
               // Event listeners
               this.startStreamBtn.addEventListener('click', () => this.startStreaming());
               this.stopBtn.addEventListener('click', () => this.stopStreaming());
              
               this.startFrameRateCounter();
               this.resetTimestamps();
               this.showControlPanel(); // Start with control center
           }
          
           // Navigation Methods
           showControlPanel() {
               this.controlPanel.style.display = 'flex';
               this.streamViewer.style.display = 'none';
               this.hideError();
               this.updateControlStatus('Ready');
               document.body.style.overflow = 'auto';
           }
          
           showStreamViewer() {
               this.controlPanel.style.display = 'none';
               this.streamViewer.style.display = 'block';
               this.isStreaming = true;
               document.body.style.overflow = 'hidden';
           }
          
           startFrameRateCounter() {
               setInterval(() => {
                   const now = Date.now();
                   const timeDiff = now - this.lastFrameTime;
                   if (timeDiff > 5000 && this.isStreaming) { // No frames for 5 seconds
                       this.updateStreamStatus('No frames received', 'disconnected');
                   }
               }, 1000);
           }
          
           async startStreaming() {
               this.setButtonLoading(this.startStreamBtn, 'startBtnText', 'startLoading', true);
              
               try {
                   console.log('Starting streaming...');
                   this.updateControlStatus('Starting...');
                  
                   // Call API to start capture
                   const response = await fetch('/api/start-capture');
                   const result = await response.json();
                   console.log('API response:', result);
                  
                   if (result.success) {
                       this.updateControlStatus('Connecting...');
                       // Switch to stream viewer and start WebSocket
                       this.showStreamViewer();
                       this.connectWebSocket();
                   } else {
                       this.showError(`Failed to start: ${result.message}`);
                   }
               } catch (error) {
                   console.error('Start streaming error:', error);
                   this.showError(`Network error: ${error.message}`);
               } finally {
                   this.setButtonLoading(this.startStreamBtn, 'startBtnText', 'startLoading', false);
               }
           }
          
           connectWebSocket() {
               const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
               const wsUrl = `${protocol}//${window.location.host}/screenshare`;
               console.log('Connecting to WebSocket:', wsUrl);
              
               this.socket = new WebSocket(wsUrl);
              
               this.socket.onopen = () => {
                   console.log('WebSocket connected successfully!');
                   this.updateStreamStatus('Connected', 'connected');
                   this.hideError();
                   this.reconnectAttempts = 0;
                  
                   // 🕒 Initialize timestamps when connected
                   this.initializeTimestamps();
               };
              
               this.socket.onmessage = (event) => {
                   try {
                       const message = JSON.parse(event.data);
                       this.handleMessage(message);
                   } catch (error) {
                       console.error('Failed to parse WebSocket message:', error);
                   }
               };
              
               this.socket.onclose = (event) => {
                   console.log('WebSocket closed - Code:', event.code, 'Reason:', event.reason);
                   this.updateStreamStatus('Disconnected', 'disconnected');
                  
                   // 🕒 Finalize timestamps when connection closes unexpectedly
                   if (this.isStreaming && !this.intentionalStop) {
                       this.finalizeTimestamps();
                       // Don't auto-reconnect, just show results on home
                       setTimeout(() => {
                           this.showControlPanel();
                       }, 2000);
                   }
               };
              
               this.socket.onerror = (error) => {
                   console.error('WebSocket error occurred:', error);
                   this.updateStreamStatus('Connection Error', 'disconnected');
                   this.showError('Failed to connect to screen sharing server. Please check your connection.');
               };
           }
          
           // 🕒 Timestamp Management
           initializeTimestamps() {
               console.log('🕒 Initializing timestamps...');
               this.startTime = new Date();
               this.stopTime = null;
               this.isStreaming = true;
              
               // Show stream controls and timestamp
               this.streamControls.classList.add('show');
               this.streamTimestamp.style.display = 'inline-block';
               this.stopBtn.style.display = 'inline-block';
              
               // Update start time
               this.compactStartTime.textContent = this.formatTime(this.startTime);
              
               // Hide session results
               this.sessionResults.style.display = 'none';
              
               // Start elapsed timer
               this.startElapsedTimer();
              
               console.log('🕒 Session started at:', this.formatDateTime(this.startTime));
               console.log('🕒 Stream controls visible:', this.streamControls.classList.contains('show'));
               console.log('🕒 Timestamp element visible:', this.streamTimestamp.style.display);
           }
          
           finalizeTimestamps() {
               this.stopTime = new Date();
               this.isStreaming = false;
              
               // Stop elapsed timer
               if (this.elapsedTimer) {
                   clearInterval(this.elapsedTimer);
                   this.elapsedTimer = null;
               }
              
               // Hide stream controls
               this.streamControls.classList.remove('show');
               this.streamTimestamp.style.display = 'none';
               this.stopBtn.style.display = 'none';
              
               // Show session results on home screen
               this.showSessionResultsOnHome();
              
               console.log('🕒 Session ended at:', this.formatDateTime(this.stopTime));
               console.log('📊 Total session duration:', this.formatDuration(this.stopTime - this.startTime));
           }
          
           startElapsedTimer() {
               this.elapsedTimer = setInterval(() => {
                   if (this.startTime && this.isStreaming) {
                       const elapsed = new Date() - this.startTime;
                       this.compactElapsedTime.textContent = this.formatDuration(elapsed);
                   }
               }, 1000); // Update every second
           }
          
           showSessionResults() {
               if (!this.startTime || !this.stopTime) return;
              
               const duration = this.stopTime - this.startTime;
              
               // Populate session results
               this.resultStartTime.textContent = this.formatTime(this.startTime);
               this.resultStopTime.textContent = this.formatTime(this.stopTime);
               this.resultDuration.textContent = this.formatDuration(duration);
               this.resultDate.textContent = this.formatDate(this.startTime);
              
               // Show session results
               this.sessionResults.style.display = 'block';
              
               // Log detailed summary to console
               console.log('📊 Complete Session Summary:', {
                   startTime: this.formatDateTime(this.startTime),
                   stopTime: this.formatDateTime(this.stopTime),
                   duration: this.formatDuration(duration),
                   durationMs: duration,
                   date: this.formatDate(this.startTime),
                   userAgent: navigator.userAgent,
                   timestamp: new Date().toISOString()
               });
              
               // Auto-hide after 30 seconds
               setTimeout(() => {
                   this.hideSessionResults();
               }, 30000);
           }
          
           hideSessionResults() {
               this.sessionResults.style.display = 'none';
               this.resetTimestamps();
           }
          
           showSessionResultsOnHome() {
               // Ensure we're on the control panel first
               this.showControlPanel();
               // Then show session results overlay
               setTimeout(() => {
                   this.showSessionResults();
               }, 100);
           }
          
           resetTimestamps() {
               this.startTime = null;
               this.stopTime = null;
               this.isStreaming = false;
              
               if (this.elapsedTimer) {
                   clearInterval(this.elapsedTimer);
                   this.elapsedTimer = null;
               }
              
               // Reset display values
               this.compactStartTime.textContent = '--:--:--';
               this.compactElapsedTime.textContent = '00:00:00';
              
               // Hide elements
               this.streamControls.classList.remove('show');
               this.streamTimestamp.style.display = 'none';
               this.stopBtn.style.display = 'none';
               this.sessionResults.style.display = 'none';
           }
          
           formatTime(date) {
               return date.toLocaleTimeString([], {
                   hour: '2-digit',
                   minute: '2-digit',
                   second: '2-digit',
                   hour12: false
               });
           }
          
           formatDateTime(date) {
               return date.toLocaleString([], {
                   year: 'numeric',
                   month: '2-digit',
                   day: '2-digit',
                   hour: '2-digit',
                   minute: '2-digit',
                   second: '2-digit',
                   hour12: false
               });
           }
          
           formatDuration(milliseconds) {
               const totalSeconds = Math.floor(milliseconds / 1000);
               const hours = Math.floor(totalSeconds / 3600);
               const minutes = Math.floor((totalSeconds % 3600) / 60);
               const seconds = totalSeconds % 60;
              
               return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
           }
          
           formatDate(date) {
               return date.toLocaleDateString([], {
                   year: 'numeric',
                   month: '2-digit',
                   day: '2-digit'
               });
           }
          
           async stopStreaming() {
               this.setButtonLoading(this.stopBtn, 'stopBtnText', 'stopLoading', true);
               this.intentionalStop = true;
              
               try {
                   console.log('🛑 Stopping streaming session...');
                  
                   // Call API to stop capture
                   const response = await fetch('/api/stop-capture');
                   const result = await response.json();
                  
                   if (result.success) {
                       console.log('✅ Capture stopped successfully');
                      
                       // 🕒 Finalize timestamps when stopping
                       this.finalizeTimestamps();
                      
                       // Close WebSocket
                       if (this.socket) {
                           this.socket.close();
                           this.socket = null;
                       }
                      
                       // Return to control center immediately to show session results
                       this.showControlPanel();
                       this.isStreaming = false;
                      
                   } else {
                       console.error('Failed to stop:', result.message);
                       this.showError(`Failed to stop: ${result.message}`);
                   }
               } catch (error) {
                   console.error('❌ Stop streaming error:', error);
                   this.finalizeTimestamps();
                   this.showError(`Network error: ${error.message}`);
               } finally {
                   this.setButtonLoading(this.stopBtn, 'stopBtnText', 'stopLoading', false);
                   setTimeout(() => {
                       this.intentionalStop = false;
                   }, 100);
               }
           }
          
           setButtonLoading(button, textId, loadingId, loading) {
               const textElement = document.getElementById(textId);
               const loadingElement = document.getElementById(loadingId);
              
               if (loading) {
                   textElement.classList.add('hidden');
                   loadingElement.classList.remove('hidden');
                   button.disabled = true;
               } else {
                   textElement.classList.remove('hidden');
                   loadingElement.classList.add('hidden');
                   button.disabled = false;
               }
           }
          


          
           handleMessage(message) {
               switch (message.type) {
                   case 'connected':
                       console.log('Server acknowledged connection');
                       break;
                      
                   case 'frame':
                       // Update the screen image with new frame data
                       this.screenView.src = message.data;
                       this.updateStreamStatus('Streaming', 'connected');
                       this.frameCount++;
                       this.lastFrameTime = Date.now();
                       break;
                      
                   default:
                       console.log('Unknown message type:', message.type);
               }
           }
          
           updateStreamStatus(text, className) {
               // Status boxes removed - can optionally use console logging
               console.log(`Stream Status: ${text} (${className})`);
           }
          
           updateControlStatus(text) {
               if (this.statusText) {
                   this.statusText.textContent = text;
               }
           }
          
           showError(message) {
               this.errorMessage.textContent = message;
               this.errorElement.style.display = 'block';
           }
          
           hideError() {
               this.errorElement.style.display = 'none';
           }
          
           attemptReconnect() {
               if (this.reconnectAttempts < this.maxReconnectAttempts && !this.intentionalStop) {
                   this.reconnectAttempts++;
                   const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
                  
                   this.updateStreamStatus(`Reconnecting in ${Math.ceil(delay/1000)}s... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 'connecting');
                  
                   setTimeout(() => {
                       this.updateStreamStatus('Reconnecting...', 'connecting');
                       this.connectWebSocket();
                   }, delay);
               } else if (!this.intentionalStop) {
                   this.showError('Failed to reconnect after multiple attempts. Please try again.');
               }
           }
       }
      
       // Initialize ScreenAI Manager when page loads
       document.addEventListener('DOMContentLoaded', () => {
           window.screenAI = new ScreenAIManager();
       });
   </script>
</body>
</html>



